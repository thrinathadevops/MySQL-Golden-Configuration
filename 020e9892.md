# MySQL 8.0 Performance Monitoring: Complete Query List & Issue Detection Guide

## Introduction

This guide provides 11 complete monitoring areas with SQL queries, result interpretation, and issue detection methods for MySQL 8.0. Since your Performance Schema is enabled, all queries will work immediately.

---

## 1Ô∏è‚É£ CONNECTION UTILISATION (MOST CRITICAL)

### Query 1.1: Max connections vs current usage

```sql
SELECT
    @@max_connections                           AS max_connections,
    COUNT(*)                                   AS current_connections,
    ROUND(COUNT(*) / @@max_connections * 100, 2) AS connection_usage_pct
FROM information_schema.PROCESSLIST;
```

**How to Read Results:**
- **< 60%**: Healthy state, plenty of headroom
- **60‚Äì80%**: Watch the trend, but not urgent
- **> 80%**: Risk zone - connection exhaustion imminent. Increase `max_connections` or find connection leaks

**Example Issue:**
```
max_connections: 500
current_connections: 425
connection_usage_pct: 85.00

‚ö†Ô∏è ACTION: Within 5% of limit. Check for connection leaks in application.
```

---

### Query 1.2: Active vs idle connections

```sql
SELECT
    SUM(CASE WHEN COMMAND <> 'Sleep' THEN 1 ELSE 0 END) AS active_connections,
    SUM(CASE WHEN COMMAND = 'Sleep' THEN 1 ELSE 0 END)  AS idle_connections,
    COUNT(*) AS total_connections
FROM information_schema.PROCESSLIST;
```

**How to Read Results:**
- **High idle (>80%)**: Application not properly closing connections
- **High active (>50%)**: Real concurrency pressure, optimize queries or scale
- **Healthy**: 70-80% idle, 20-30% active

**Example Issue:**
```
active_connections: 8
idle_connections: 417
total_connections: 425

‚ö†Ô∏è ACTION: 98% idle connections! Application has misconfigured connection pool.
   Review: connection_timeout, max_idle_time, pool_size settings in app.
```

---

### Query 1.3: Peak connections ever used

```sql
SHOW GLOBAL STATUS LIKE 'Max_used_connections';
```

**How to Read Results:**
```
Variable_name: Max_used_connections
Value: 387
```

Compare with current `@@max_connections`:
- If `Max_used_connections = 450` and `@@max_connections = 500` ‚Üí Safe (50 connection headroom)
- If `Max_used_connections = 480` and `@@max_connections = 500` ‚Üí Unsafe (only 20 headroom, increase to 750)

---

### Query 1.4: Threads running vs threads connected

```sql
SHOW GLOBAL STATUS LIKE 'Threads_running';
SHOW GLOBAL STATUS LIKE 'Threads_connected';
```

**How to Read Results:**
```
Threads_running: 14
Threads_connected: 387

Healthy Ratio: 14 << 387 ‚úÖ (Most connections idle)
```

**Issue Detection:**
- If `Threads_running ‚âà Threads_connected` (e.g., 380 running, 387 connected) ‚Üí All sessions active, likely overload
- If `Threads_running > CPU_cores` (e.g., 32 running on 8-core CPU) ‚Üí CPU contention, queries waiting for CPU

---

## 2Ô∏è‚É£ CONNECTION CHURN RATE (VERY IMPORTANT)

### Query 2.1: Connection statistics

```sql
SHOW GLOBAL STATUS LIKE 'Connections';
SHOW GLOBAL STATUS LIKE 'Aborted_connects';
SHOW GLOBAL STATUS LIKE 'Aborted_clients';
```

**Expected Output:**
```
Variable_name: Connections
Value: 12847

Variable_name: Aborted_connects
Value: 5

Variable_name: Aborted_clients
Value: 18
```

**How to Find Issues:**

1. **Monitor daily growth** (run query daily at same time):
   - Day 1: `Connections: 5000`
   - Day 2: `Connections: 7500` (2500 new connections)
   - Day 3: `Connections: 10200` (2700 new connections)
   
   This is normal growth. But if growing by 20,000+ daily ‚Üí Connection leak

2. **High Aborted_connects** (> 10):
   - Indicates authentication failures
   - Check: Wrong passwords, user quotas, firewall blocking

3. **High Aborted_clients** (> 50):
   - Application crashes or network timeouts
   - Check: Server logs, network stability, app crash logs

---

## 3Ô∏è‚É£ INNODB BUFFER POOL UTILISATION

### Query 3.1: Buffer pool configuration

```sql
SELECT
    @@innodb_buffer_pool_size / 1024 / 1024 / 1024 AS buffer_pool_gb,
    @@innodb_buffer_pool_instances AS instances;
```

**Expected Output:**
```
buffer_pool_gb: 40.00
instances: 8
```

Rule of thumb: Buffer pool should be **50-80% of total RAM** for dedicated server

---

### Query 3.2: Buffer pool hit ratio (CRITICAL FOR PERFORMANCE)

```sql
SELECT
    ROUND(
        100 - (
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
        ) * 100,
        2
    ) AS buffer_pool_hit_ratio_pct;
```

**How to Read Results:**
- **>= 99%**: Perfect (data in memory, zero disk reads)
- **95‚Äì99%**: Good (most data in memory)
- **90‚Äì95%**: Warning (some disk reads happening)
- **< 90%**: Critical (buffer pool too small)

**Example Issue:**
```
buffer_pool_hit_ratio_pct: 87.50

üî¥ CRITICAL: Buffer pool undersized!
Calculate needed size:
  Current: 40GB
  Current ratio: 87.50%
  Needed size = 40 * (87.50 / 99) = 35.35GB (wait, that's smaller!)
  
Actually: If ratio is 87.5%, need LARGER pool.
Recommendation: Increase to 50-60GB and monitor.
```

---

### Query 3.3: Buffer pool pages state

```sql
SHOW GLOBAL STATUS LIKE 'Innodb_buffer_pool_pages_%';
```

**Expected Output:**
```
Innodb_buffer_pool_pages_data: 2097152
Innodb_buffer_pool_pages_dirty: 52428
Innodb_buffer_pool_pages_free: 0
Innodb_buffer_pool_pages_flushed: 8388608
Innodb_buffer_pool_pages_total: 2621440
```

**Interpretation:**
- **pages_data**: 2097152 (data pages in use) = healthy if > 80% of total
- **pages_dirty**: 52428 (unflushed pages waiting to write) = 2% of total = normal
- **pages_free**: 0 (unused memory) = buffer pool fully utilized

**Dirty Pages Pressure:**

```sql
SELECT
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100,
        2
    ) AS dirty_pages_pct;
```

| Dirty % | Status | Action |
|---------|--------|--------|
| < 10% | ‚úÖ Healthy | Normal write activity |
| 10‚Äì30% | ‚ö†Ô∏è Monitor | Flushing keeping up |
| > 30% | üî¥ Pressure | Increase innodb_io_capacity |

**Example Issue:**
```
dirty_pages_pct: 45.50

üî¥ CRITICAL: Too many unflushed pages!
Solutions:
  1. Increase innodb_io_capacity from 200 to 500
  2. Check if disk is slow: iostat -x 5
  3. Reduce write workload or add replicas
```

---

## 4Ô∏è‚É£ REDO LOG & WRITE PRESSURE

### Query 4.1: Redo log pressure

```sql
SELECT
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_os_log_written') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Uptime'),
        2
    ) AS redo_bytes_per_sec,
    @@innodb_log_file_size / 1024 / 1024 AS log_file_size_mb,
    ROUND(
        @@innodb_log_file_size / (
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_os_log_written') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Uptime')
        ),
        2
    ) AS seconds_to_fill_log;
```

**How to Read Results:**
```
redo_bytes_per_sec: 125.45
log_file_size_mb: 512
seconds_to_fill_log: 4.10

üî¥ CRITICAL: Redo log fills in 4 seconds!
  Checkpoint storms happening every few seconds.
  
  Solution: Increase innodb_log_file_size to 4096 (4GB)
  This allows 32 seconds between checkpoints.
```

**Rule of thumb:**
- Redo log should fill in **30-60 seconds minimum**
- Safe size = `redo_bytes_per_sec √ó 60 √ó number_of_log_files`

---

### Query 4.2: Log waits (critical indicator)

```sql
SHOW GLOBAL STATUS LIKE 'Innodb_log_waits';
```

**Expected Output:**
```
Variable_name: Innodb_log_waits
Value: 0
```

**Issue Detection:**
- **Value = 0**: Perfect, no redo bottleneck
- **Value > 0 and increasing**: Redo log too small, transactions waiting
- **Value growing continuously**: Critical issue, increase redo log size immediately

**Example Issue:**
```
Innodb_log_waits: 245

üî¥ CRITICAL: 245 transactions waited for redo log flush!
Action: Immediately increase innodb_log_file_size
  Current: 512 MB
  Recommended: 4096 MB (4GB)
  
Note: Requires server restart or using MySQL 8.0.30+ for online resize
```

---

## 5Ô∏è‚É£ INNODB ROW OPERATIONS (REAL WORKLOAD ANALYSIS)

### Query 5.1: Row operation counts

```sql
SHOW GLOBAL STATUS LIKE 'Innodb_rows_read';
SHOW GLOBAL STATUS LIKE 'Innodb_rows_inserted';
SHOW GLOBAL STATUS LIKE 'Innodb_rows_updated';
SHOW GLOBAL STATUS LIKE 'Innodb_rows_deleted';
```

**Expected Output:**
```
Innodb_rows_read: 145000000
Innodb_rows_inserted: 3500000
Innodb_rows_updated: 2100000
Innodb_rows_deleted: 1800000
```

**How to Analyze:**

```sql
-- Calculate read/write ratio
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_rows_read') AS read_rows,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_rows_inserted') AS insert_rows,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_rows_updated') AS update_rows,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status 
     WHERE VARIABLE_NAME = 'Innodb_rows_deleted') AS delete_rows;
```

**Interpret Workload Type:**
```
read_rows: 145000000
write_rows: (3500000 + 2100000 + 1800000) = 7400000

Ratio: 145000000 / 7400000 = 19.6:1 (Read-heavy workload)

Implication:
- Focus on SELECT optimization, caching (Redis), query tuning
- Less concern about redo log size
- Buffer pool undersizing is the main issue
```

**Workload Classifications:**
| Ratio | Type | Optimization Focus |
|-------|------|-------------------|
| > 50:1 | Read-heavy | Caching, index optimization |
| 10:1 - 50:1 | Mixed | Balanced tuning |
| < 10:1 | Write-heavy | Redo log sizing, flushing |

---

## 6Ô∏è‚É£ TEMP TABLE UTILISATION (MEMORY VS DISK)

### Query 6.1: Temp table disk spill analysis

```sql
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Created_tmp_tables') AS total_tmp_tables,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') AS disk_tmp_tables,
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Created_tmp_tables') * 100,
        2
    ) AS disk_spill_pct,
    @@tmp_table_size / 1024 / 1024 AS tmp_table_size_mb,
    @@max_heap_table_size / 1024 / 1024 AS max_heap_table_size_mb;
```

**How to Read Results:**
```
total_tmp_tables: 125000
disk_tmp_tables: 50000
disk_spill_pct: 40.00
tmp_table_size_mb: 16
max_heap_table_size_mb: 16

üî¥ CRITICAL: 40% of temp tables spilling to disk!
Action: Increase both tmp_table_size and max_heap_table_size to 256-512 MB
```

**Issue Detection:**
| Disk % | Status | Action |
|--------|--------|--------|
| < 5% | ‚úÖ Good | Temp tables fitting in memory, no action |
| 5‚Äì20% | ‚ö†Ô∏è Watch | Some spills, consider increasing size |
| > 20% | üî¥ Issue | Many spills, increase or optimize queries |

**How to Fix:**
```sql
-- Check current setting
SHOW VARIABLES LIKE 'tmp_table_size';
SHOW VARIABLES LIKE 'max_heap_table_size';

-- Increase (both must be same for heap tables)
SET GLOBAL tmp_table_size = 268435456;      -- 256 MB
SET GLOBAL max_heap_table_size = 268435456;

-- Find problematic queries
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    SUM_ROWS_EXAMINED,
    SUM_ROWS_EXAMINED / COUNT_STAR AS avg_rows_examined
FROM performance_schema.events_statements_summary_by_digest
WHERE DIGEST_TEXT LIKE '%GROUP BY%' OR DIGEST_TEXT LIKE '%ORDER BY%'
ORDER BY SUM_ROWS_EXAMINED DESC LIMIT 10;
```

---

## 7Ô∏è‚É£ INNODB LOCK CONTENTION (CRITICAL)

### Query 7.1: Row lock waits

```sql
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Innodb_row_lock_waits') AS row_lock_waits,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Innodb_row_lock_time') AS row_lock_time_total_ms,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Innodb_row_lock_time_avg') AS row_lock_time_avg_ms;
```

**Expected Output:**
```
row_lock_waits: 342
row_lock_time_total_ms: 654300
row_lock_time_avg_ms: 1912
```

**Issue Detection:**
| Metric | Healthy | Warning | Critical | Action |
|--------|---------|---------|----------|--------|
| row_lock_waits | < 100 | 100-500 | > 1000 | Find blocking queries |
| row_lock_time_avg_ms | < 10 | 10-100 | > 100 | Add indexes, optimize |

**Example Issue:**
```
row_lock_waits: 2500
row_lock_time_avg_ms: 850

üî¥ CRITICAL: Heavy lock contention!
  2500 transactions waited average 850ms for locks.
  
Solutions:
  1. Check for missing indexes on WHERE clause
  2. Look for "hot rows" everyone is updating
  3. Reduce transaction duration
  4. Use lower isolation levels (if safe)
```

**Find problematic queries:**
```sql
SELECT 
    PROCESSLIST.ID,
    PROCESSLIST.USER,
    PROCESSLIST.HOST,
    PROCESSLIST.DB,
    PROCESSLIST.COMMAND,
    PROCESSLIST.TIME,
    PROCESSLIST.STATE,
    PROCESSLIST.INFO,
    TRX.TRX_ID,
    TRX.TRX_STATE,
    TRX.TRX_STARTED,
    TRX.TRX_ISOLATION_LEVEL
FROM INFORMATION_SCHEMA.PROCESSLIST PROCESSLIST
LEFT JOIN INFORMATION_SCHEMA.INNODB_TRX TRX ON PROCESSLIST.ID = TRX.TRX_MYSQL_THREAD_ID
WHERE TRX.TRX_STATE = 'RUNNING' AND TRX.TRX_STARTED < DATE_SUB(NOW(), INTERVAL 10 SECOND);
```

---

## 8Ô∏è‚É£ DEADLOCK FREQUENCY (CRITICAL)

### Query 8.1: Detect recent deadlocks

```sql
SHOW ENGINE INNODB STATUS;
```

**What to Look For:**

Search for `LATEST DETECTED DEADLOCK` in the output.

**Example Deadlock:**
```
LATEST DETECTED DEADLOCK
------------------------
2025-12-30 15:45:23 0x1234
*** (1) TRANSACTION:
TRANSACTION 12345, ACTIVE 5 sec
2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1
MySQL thread id 45, OS thread handle 0x5678, query id 9876 root
UPDATE users SET status = 'active' WHERE id = 100;
*** (2) TRANSACTION:
TRANSACTION 12346, ACTIVE 3 sec
2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1
MySQL thread id 46, OS thread handle 0x5678, query id 9877 root
UPDATE users SET status = 'inactive' WHERE id = 100;
```

**Issue Detection:**
- **No deadlocks**: Perfect
- **1-5 per day**: Acceptable, but investigate
- **> 5 per day**: Design issue, transactions not ordered properly

**Solution:**
Both transactions lock the same row in opposite order. Fix:
```sql
-- Transaction 1: Always lock in order: id=100, then id=200
UPDATE users SET status = 'active' WHERE id IN (100, 200) ORDER BY id;

-- Transaction 2: Same order
UPDATE users SET status = 'inactive' WHERE id IN (100, 200) ORDER BY id;
```

---

## 9Ô∏è‚É£ FILE I/O ACTIVITY (ACTUAL I/O)

### Query 9.1: InnoDB I/O statistics

```sql
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Innodb_data_reads') AS io_reads,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Innodb_data_writes') AS io_writes,
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_data_read') / 1024 / 1024,
        2
    ) AS total_read_mb,
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_data_written') / 1024 / 1024,
        2
    ) AS total_written_mb,
    @@innodb_io_capacity AS io_capacity,
    @@innodb_io_capacity_max AS io_capacity_max;
```

**How to Calculate I/O Per Second:**
```sql
SELECT
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_data_writes') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Uptime'),
        2
    ) AS writes_per_sec,
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_data_read') / 1024 / 1024 /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Uptime'),
        2
    ) AS read_mb_per_sec;
```

**Issue Detection:**
```
writes_per_sec: 450
read_mb_per_sec: 125
io_capacity: 200
io_capacity_max: 2000

‚ö†Ô∏è BOTTLENECK DETECTED:
  Current write rate: 450 writes/sec
  Configuration allows: 200 writes/sec
  
  Solution: Increase innodb_io_capacity to 500-1000
```

| Metric | Healthy | Warning | Critical |
|--------|---------|---------|----------|
| writes_per_sec | < 50 | 50-200 | > 200 |
| read_mb_per_sec | < 50 | 50-200 | > 200 |

---

## üîü PERFORMANCE SCHEMA MEMORY (OVERHEAD CHECK)

### Query 10.1: Top memory consumers

```sql
SELECT
    EVENT_NAME,
    CURRENT_NUMBER_OF_BYTES_USED / 1024 / 1024 AS MB_Used,
    CURRENT_COUNT_ALLOC - CURRENT_COUNT_FREE AS outstanding_allocations
FROM performance_schema.memory_summary_global_by_event_name
ORDER BY MB_Used DESC
LIMIT 15;
```

**Expected Output:**
```
EVENT_NAME                                MB_Used    outstanding_allocations
memory/innodb/buf_buf_pool                40512.50   1
memory/innodb/page_hash_table             256.75     2
memory/performance_schema/events_stmt     128.40     0
memory/sql/parser                         64.20      0
```

**Issue Detection:**
- **PS memory > 5% of total RAM**: Reduce instrumentation overhead
  
  On 86GB server: 5% = 4.3GB. If PS using > 4GB, optimize.

**How to Reduce PS Overhead:**
```sql
-- Disable expensive statement tracking
UPDATE performance_schema.setup_instruments 
SET ENABLED='NO', TIMED='NO' 
WHERE NAME LIKE 'statement/%' AND NAME NOT LIKE '%sql%';

-- Disable some waits
UPDATE performance_schema.setup_instruments 
SET ENABLED='NO' 
WHERE NAME LIKE 'wait/io/file/sql/FRM';
```

---

## 1Ô∏è‚É£1Ô∏è‚É£ TABLE CACHE UTILISATION

### Query 11.1: Table cache analysis

```sql
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Open_tables') AS open_tables,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Opened_tables') AS opened_tables,
    @@table_open_cache AS table_open_cache_limit;
```

**Expected Output:**
```
open_tables: 450
opened_tables: 12500
table_open_cache_limit: 800
```

**Issue Detection:**
```
open_tables: 450
table_open_cache_limit: 800
Usage: 450 / 800 = 56.25% ‚úÖ Healthy
```

| Scenario | Status | Action |
|----------|--------|--------|
| open_tables << cache_limit | ‚úÖ OK | Cache properly sized |
| open_tables ‚âà cache_limit | ‚ö†Ô∏è Watch | Approaching limit |
| open_tables = cache_limit | üî¥ Issue | Cache exhausted, increase limit |

**Example Issue:**
```
open_tables: 798
table_open_cache_limit: 800

üî¥ CRITICAL: Cache almost exhausted!
Action: Increase table_open_cache from 800 to 1600
  SET GLOBAL table_open_cache = 1600;
```

**Cache Efficiency:**
```sql
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Opened_tables') - 1 AS normalized_open,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Opened_tables') AS total_open,
    ROUND(
        ((SELECT VARIABLE_VALUE FROM performance_schema.global_status
          WHERE VARIABLE_NAME = 'Opened_tables') - 1) /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Opened_tables') * 100,
        2
    ) AS cache_hit_pct;
```

Higher cache_hit_pct = better. If < 95%, increase table_open_cache.

---

## üî¥ BONUS: THREAD CACHE EFFICIENCY

### Query 12.1: Thread creation overhead

```sql
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Threads_created') AS threads_created,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status
     WHERE VARIABLE_NAME = 'Connections') AS total_connections,
    @@thread_cache_size AS thread_cache_limit,
    ROUND(
        ((SELECT VARIABLE_VALUE FROM performance_schema.global_status
          WHERE VARIABLE_NAME = 'Connections') - 
         (SELECT VARIABLE_VALUE FROM performance_schema.global_status
          WHERE VARIABLE_NAME = 'Threads_created')) /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Connections') * 100,
        2
    ) AS thread_reuse_pct;
```

**Expected Output:**
```
threads_created: 245
total_connections: 4872
thread_cache_limit: 100
thread_reuse_pct: 94.97
```

**Issue Detection:**
```
thread_reuse_pct: 94.97

‚úÖ EXCELLENT: 95% of connections reused from cache.
This means thread creation overhead is minimal.
```

| Reuse % | Status | Action |
|---------|--------|--------|
| > 95% | ‚úÖ Excellent | Good thread caching |
| 90‚Äì95% | ‚ö†Ô∏è Acceptable | Acceptable |
| < 90% | üî¥ Issue | Increase thread_cache_size |

**Fix if needed:**
```sql
SET GLOBAL thread_cache_size = 200;
```

---

## üìä DAILY HEALTH CHECK SCRIPT

Run this every morning to catch all issues:

```sql
-- Save this as daily_health_check.sql

-- 1. Connection Status
SELECT '========== CONNECTION STATUS ==========' AS status;
SELECT
    @@max_connections AS max_allowed,
    (SELECT COUNT(*) FROM information_schema.PROCESSLIST) AS current_count,
    ROUND((SELECT COUNT(*) FROM information_schema.PROCESSLIST) / @@max_connections * 100, 2) AS usage_pct,
    CASE 
        WHEN (SELECT COUNT(*) FROM information_schema.PROCESSLIST) / @@max_connections * 100 > 80 THEN 'üî¥ CRITICAL'
        WHEN (SELECT COUNT(*) FROM information_schema.PROCESSLIST) / @@max_connections * 100 > 60 THEN '‚ö†Ô∏è WARNING'
        ELSE '‚úÖ OK'
    END AS status;

-- 2. Buffer Pool Hit Ratio
SELECT '========== BUFFER POOL HIT RATIO ==========' AS status;
SELECT
    ROUND(
        100 - (
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
        ) * 100, 2
    ) AS hit_ratio_pct,
    CASE
        WHEN ROUND(
            100 - (
                (SELECT VARIABLE_VALUE FROM performance_schema.global_status
                 WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads') /
                (SELECT VARIABLE_VALUE FROM performance_schema.global_status
                 WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests')
            ) * 100, 2) >= 95 THEN '‚úÖ OK'
        ELSE 'üî¥ CRITICAL'
    END AS status;

-- 3. Dirty Pages Percentage
SELECT '========== DIRTY PAGES ==========' AS status;
SELECT
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status
         WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2
    ) AS dirty_pct,
    CASE
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2) > 30 THEN 'üî¥ PRESSURE'
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_dirty') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status
             WHERE VARIABLE_NAME = 'Innodb_buffer_pool_pages_total') * 100, 2) > 10 THEN '‚ö†Ô∏è WATCH'
        ELSE '‚úÖ OK'
    END AS status;

-- 4. Redo Log Waits
SELECT '========== REDO LOG WAITS ==========' AS status;
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_log_waits') AS log_waits,
    CASE
        WHEN (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_log_waits') > 10 THEN 'üî¥ CRITICAL'
        WHEN (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_log_waits') > 0 THEN '‚ö†Ô∏è WARNING'
        ELSE '‚úÖ OK'
    END AS status;

-- 5. Lock Contention
SELECT '========== ROW LOCK CONTENTION ==========' AS status;
SELECT
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_row_lock_waits') AS lock_waits,
    (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_row_lock_time_avg') AS avg_wait_ms,
    CASE
        WHEN (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_row_lock_waits') > 1000 THEN 'üî¥ CRITICAL'
        WHEN (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Innodb_row_lock_waits') > 500 THEN '‚ö†Ô∏è WARNING'
        ELSE '‚úÖ OK'
    END AS status;

-- 6. Temp Table Disk Spills
SELECT '========== TEMP TABLE DISK SPILLS ==========' AS status;
SELECT
    ROUND(
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') /
        (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Created_tmp_tables') * 100, 2
    ) AS disk_spill_pct,
    CASE
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Created_tmp_tables') * 100, 2) > 20 THEN 'üî¥ ISSUE'
        WHEN ROUND(
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Created_tmp_disk_tables') /
            (SELECT VARIABLE_VALUE FROM performance_schema.global_status WHERE VARIABLE_NAME = 'Created_tmp_tables') * 100, 2) > 5 THEN '‚ö†Ô∏è WATCH'
        ELSE '‚úÖ OK'
    END AS status;

-- 7. Overall Status
SELECT '========== SUMMARY ==========' AS status;
SELECT
    'All systems checked' AS result,
    NOW() AS check_time;
```

---

## üéØ QUICK TROUBLESHOOTING REFERENCE

| Problem | Symptoms | Check These Queries | Quick Fix |
|---------|----------|---------------------|-----------|
| **Connection Exhaustion** | "Too many connections" error | 1.1, 1.3, 2.1 | Increase max_connections, debug app |
| **Slow Database** | High latency | 3.2, 5.1, 9.1 | Increase buffer pool or optimize queries |
| **High Memory Usage** | OOM killer triggered | 3.3, 10.1 | Reduce buffer pool or disable PS instruments |
| **Slow Inserts** | INSERT taking seconds | 4.2, 7.1, 8.1 | Check redo log size, lock contention |
| **Disk I/O Bottleneck** | High disk wait | 4.1, 9.1 | Increase io_capacity, optimize queries |
| **Deadlocks** | Occasional transaction failures | 8.1 | Review transaction code, reorder locks |
| **Table Cache Full** | "Too many open files" | 11.1 | Increase table_open_cache |
| **Temp Disk Spills** | GROUP BY/ORDER BY slow | 6.1 | Increase tmp_table_size |

---

## Final Notes

- Run these queries regularly (daily for production systems)
- Set up monitoring alerts at thresholds mentioned
- Keep baseline metrics for trend analysis
- All queries are MySQL 8.0 compatible with Performance Schema enabled

